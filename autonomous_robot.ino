#include <PIDController.h>
#include <math.h>
//pins declarations
#define DMOTOR1 2
#define DMOTOR1D 3
#define DIRECTION1M1 39
#define DIRECTION2M1 43
#define PWM1 9
#define DMOTOR2 18
#define DMOTOR2D 19
#define DIRECTION1M2 51
#define DIRECTION2M2 53
#define PWM2 10
#define TRIGPIN1  11   //the first ultrasonic sensor placed on the front side of the robot
#define ECHOPIN1 12
#define TRIGPIN1  2   //the second ultrasonic sensor placed on the right of the robot
#define ECHOPIN1 3   

//defining constants
#define d_baseline 20  //the distance between the two wheels' centers
#define wheel_diameter 6 // the diameter of the wheel in centimeters
#define ticks_per_revolution 480 //the number of pulses generated by the encoder when it completes a full rotation

struct point{
    float x,y;
}point;

//coordinates
point path[5]{{10,10},{20,50},{70,80},{100,20},{-10,20}}; //the path of the robot
point p_target;
volatile float x_current=0,y_current=0; //the current location of the robot

//variables declarations
PIDController pos_pid1;
PIDController pos_pid2;
PIDController error;
volatile long int encoder_pos1 = 0; //the desired distance of the first motor
volatile long int encoder_pos2 = 0; //the desired distance of the second motor
volatile int counter = 0;
int motor_value1;
int motor_value2;
int motor_mode = 1; 
int v_limit1 = 250;
int v_limit2 = 250;
float d_right,d_left;//the distance made by the right and left wheels
float distance; //the translation of the robot from the current point to the target point after it rotates
float distance_right,distance_left;
float orientation;
int Orientate_permission = 1;
float theta;

//FUNCTIONS DECLARATIONS
 void encoder1(); //the function encoder is used to convert the binary sequence recieved from the encoder into a useful information expressed in integer number
// using a counter every time an event occures , this information is used after that to regulate either the position the the speed of the motor.
 void encoder2();
 void Motor1Clockwise(int); // rotation in the one direction for the first motor
 void Motor2Clockwise(int); // rotation in the one direction for the second motor
 void Motor1CounterClockwise(int); // rotation in the other direction for the first motor
 void Motor2CounterClockwise(int); // rotation in the other direction for the second motor


 void Move(void); // after executing this function the two motors will rotate in a specific direction based on the sign of encoder_pos1 and 2
 int obstacle(void); // this function is used to stop the two motors in case of encountring an unexpected obstacle
 int obstacle_on_the_right(void); 
 void Upgrade_location(float &x_current, float &y_current, float &theta);
 
void setup()
{
  //defining pin types
  pinMode(DMOTOR1,INPUT);
  pinMode(DMOTOR1D,INPUT);
  pinMode(DIRECTION1M1, OUTPUT);
  pinMode(DIRECTION2M1, OUTPUT);
  pinMode(PWM1,OUTPUT);
  pinMode(DMOTOR2,INPUT);
  pinMode(DMOTOR2D,INPUT);
  pinMode(DIRECTION1M2, OUTPUT);
  pinMode(DIRECTION2M2, OUTPUT);
  pinMode(PWM2,OUTPUT);
  pinMode(TRIGPIN1, OUTPUT);
  pinMode(ECHOPIN1, INPUT);
  Serial.begin(115200);
  
  // setting the PID controller
  attachInterrupt(digitalPinToInterrupt(DMOTOR1D),encoder1,RISING);
  attachInterrupt(digitalPinToInterrupt(DMOTOR2D),encoder2,RISING);
  pos_pid1.begin();    
  pos_pid1.tune(50, 0 ,5000);    
  pos_pid1.limit(-120, 120);
  pos_pid1.setpoint(0);
  pos_pid2.begin();    
  pos_pid2.tune(50, 0,5200);    
  pos_pid2.limit(-120, 120);
  pos_pid2.setpoint(0);
  delay(100);
}

void loop()
{
    Upgrade_location(x_current,y_current,theta);
    p_target.x=path[counter].x;
    p_target.y=path[counter].y;
    if(distance == 0)
    {
        counter++;
    }
    if(!obstacle()&&!obstacle_on_the_right()&&((x_current == 0 && y_current == 0)||(x_current == path[counter.x] && y_current == path[counter.y])))
    {
        distance = sqrt((p_target.x-x_current)*(p_target.x-x_current)+(p_target.y-y_current)*(p_target.y-y_current));
        orientation = atan((p_target.y-y_current)/(p_target.x-x_current));
        distance_right = (d_baseline/2)*orientation;
        distance_left = -(d_baseline/2)*orientation;

    }
    if(!orientate_robot())
    {
        orientate_robot();
    }
    else{
        move();
    }
  delay(20);
}

// t
void encoder1()
  {
    
    if(digitalRead(DMOTOR1) == HIGH)
    {
      encoder_pos1++;
    }
    else
    {
      encoder_pos1--;
    }
  }
void encoder2()
  {
    
    if(digitalRead(DMOTOR2) == HIGH)
    {
      encoder_pos2++;
    }
    else
    {
      encoder_pos2--;
    }
  }
  
  void Motor1Clockwise(int power){
  if(power > 100){
  digitalWrite(DIRECTION1M1, HIGH);
  digitalWrite(DIRECTION2M1, LOW);
  analogWrite(PWM1, power);
  }else{
    digitalWrite(DIRECTION1M1, LOW);
    digitalWrite(DIRECTION2M1, LOW);
  }
}

void Motor1CounterClockwise(int power){
  if(power > 100){
  digitalWrite(DIRECTION1M1, LOW);
  digitalWrite(DIRECTION2M1, HIGH);
  analogWrite(PWM1, power);
  
  }else{
    digitalWrite(DIRECTION1M1, LOW);
    digitalWrite(DIRECTION2M1, LOW);
  }
}
void Motor2Clockwise(int power){
  if(power > 100){
  digitalWrite(DIRECTION1M2, HIGH);
  digitalWrite(DIRECTION2M2, LOW);
  analogWrite(PWM2, power);
  }else{
    digitalWrite(DIRECTION1M2, LOW);
    digitalWrite(DIRECTION2M2, LOW);
  }
}

void Motor2CounterClockwise(int power){
  if(power > 100){
  digitalWrite(DIRECTION1M2, LOW);
  digitalWrite(DIRECTION2M2, HIGH);
  analogWrite(PWM2, power);
  
  }else{
    digitalWrite(DIRECTION1M2, LOW);
    digitalWrite(DIRECTION2M2, LOW);
  }
}

//function for stoping the robot
void STOP(void)
{
  int i=1;
  if(i)
  {
  analogWrite(PWM2, -motor_value2);
  analogWrite(PWM1, -motor_value1);
  delay(600);
  i=0;
  }
  else{
      analogWrite(PWM2, 50);
      analogWrite(PWM1, 50);
  }
}


void Move( void )
{
   motor_value1 =  pos_pid1.compute(distance);
   motor_value2 =  pos_pid2.compute(distance);
   if(motor_value2 > 0){
       if(motor_value2>v_limit2) motor_value2=v_limit2;
    Motor2CounterClockwise(motor_value2);
   }else{
       if(motor_value2<-v_limit2) motor_value2=-v_limit2;
    Motor2Clockwise(abs(motor_value2));
   }
   if(motor_value1 > 0){
       if(motor_value1>v_limit1) motor_value1=v_limit1;
    Motor1CounterClockwise(motor_value1);
   }else{
       if(motor_value1<-v_limit1) motor_value1=-v_limit1;
    Motor1Clockwise(abs(motor_value1));
   }
}

int orientate_robot(void)
{
    int orientation_ended = 0;
    if(distance_left==0 && distance_right ==0)
    {
        orientation_ended = 1;
    }
    motor_value1 =  pos_pid1.compute(distance_left);
    motor_value2 =  pos_pid2.compute(distance_right);
   if(motor_value2 > 0){
       if(motor_value2>v_limit2) motor_value2=v_limit2;
    Motor2CounterClockwise(motor_value2);
   }else{
       if(motor_value2<-v_limit2) motor_value2=-v_limit2;
    Motor2Clockwise(abs(motor_value2));
   }
   if(motor_value1 > 0){
       if(motor_value1>v_limit1) motor_value1=v_limit1;
    Motor1CounterClockwise(motor_value1);
   }else{
       if(motor_value1<-v_limit1) motor_value1=-v_limit1;
    Motor1Clockwise(abs(motor_value1));
   }
    return orientation_ended;
}

//functions for rising a flag in case an obstacle exists in front or on the right side of the robot

int obstacle(void)
{
  int flag = 0;
  float duration,distance;
  digitalWrite(TRIGPIN1, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIGPIN1, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIGPIN1, LOW);
  duration = pulseIn(ECHOPIN1, HIGH);
  distance = duration*0.034/2;
  if(distance < 5) flag = 1;
  else flag = 0;

  return flag;
  
}

int obstacle_on_the_right(void)
{
    float duration,distance;
    int flag = 0;
    digitalWrite(TRIGPIN1, LOW);
    delayMicroseconds(2);
    digitalWrite(TRIGPIN1, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIGPIN1, LOW);
    duration = pulseIn(ECHOPIN1, HIGH);
    distance = duration*0.034/2;
    if(distance < 5) flag = 1;
    else flag = 0;

  return flag;
}

void Upgrade_location(float &x_current, float &y_current, float &theta)
{
    float phi,d_center;
    d_right = encoder_pos2/(ticks_per_revolution/(3.14*wheel_diameter));
    d_right = encoder_pos1/(ticks_per_revolution/(3.14*wheel_diameter));
    phi = (d_right-d_left)/d_baseline;
    theta+= phi;
    d_center = (d_right+d_left)/2;
    x_current+=d_center*sin(theta);
    y_current+=d_center*cos(theta);
}